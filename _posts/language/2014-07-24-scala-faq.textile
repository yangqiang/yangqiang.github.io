---
layout: post
title: "Scala 语法常见小问题记录"
description: ""
category: Language
tags: [Scala]
---
{% include JB/setup %}

h2. view, stream 和 iterator 之差异

First, they are all non-strict. That has a particular mathematical meaning related to functions, but, basically, means they are computed on-demand instead of in advance.

Stream is a lazy list indeed. In fact, in Scala, a Stream is a List whose tail is a lazy val. Once computed, a value stays computed and is reused. Or, as you say, the values are cached.

An Iterator can only be used once because it is a traversal pointer into a collection, and not a collection in itself. What makes it special in Scala is the fact that you can apply transformation such as map and filter and simply get a new Iterator which will only apply these transformations when you ask for the next element.

Scala used to provide iterators which could be reset, but that is very hard to support in a general manner, and they didn’t make version 2.8.0.

Views are meant to be viewed much like a database view. It is a series of transformation which one applies to a collection to produce a “virtual” collection. As you said, all transformations are re-applied each time you need to fetch elements from it.

Both Iterator and views have excellent memory characteristics. Stream is nice, but, in Scala, its main benefit is writing infinite sequences (particularly sequences recursively defined). One can avoid keeping all of the Stream in memory, though, by making sure you don’t keep a reference to its head (for example, by using def instead of val to define the Stream).

Because of the penalties incurred by views, one should usually force it after applying the transformations, or keep it as a view if only few elements are expected to ever be fetched, compared to the total size of the view.

http://docs.scala-lang.org/tutorials/FAQ/stream-view-iterator.html
http://stackoverflow.com/questions/5159000/stream-vs-views-vs-iterators

h2. 类型名后面的 *

def apply[A](elems: A*): Iterator[A] = elems.iterator

&lt;&lt;Programming in Scala&gt;&gt;8.8 小节：Special function call forms 对 Repeated parameters 的描述举了这个例子：

<pre>
scala> def echo(args: String*) =
  for (arg <- args) println(arg)
echo: (args: String*)Unit

scala> echo("one")
one
scala> echo("hello", "world!")
hello
world!
</pre>

可见，*的含义是同类型的形式参数。
*&lt;&lt;Programming in Scala&gt;&gt;这本电子书的 index 部分可以用来查询 scala 语言细节问题。*

h2. apply 方法

object 的构造方法，可以不使用 new 关键字创建对象，比如 Array 类型。在 《Scala Cookbook》6.8小结中提到:

<pre>
To demonstrate the first approach, define a Person  class and Person object in the same
file. Define an  applymethod in the object that takes the desired parameters. This meth‐
od is essentially the constructor of your class:

class Person {
  var name: String = _
}

object Person {
  def apply(name: String): Person = {
    var p = new Person
    p.name = name
    p
  }
}
Given this definition, you can create new Personinstances without using the newkey‐
word, as shown in these examples:
val dawn = Person("Dawn")
val a = Array(Person("Dan"), Person("Elijah"))
The apply  method in a companion object is treated specially by the Scala compiler and
lets you create new instances of your class without requiring the  newkeyword.
</pre>

h2. case 关键字的几种用法

case 

h2. 接口中的 self

trait TraversableOnce[+A] extends Any with GenTraversableOnce[A] {
  self =>
  
  def foreach[U](f: A => U): Unit
  ...
}

后面的方法中可以直接使用 self。

h2. 类型定义

Class[A]：只接受 A 类型
Class[+A]：可接受 A 的子类型
Class[-A]：可接受 A 的父类型

A <: B Upper bound Amust be a subtype of B. See Recipe 19.6.
A >: B Lower bound Amust be a supertype of B. Not commonly used. See Recipe 19.8.
A <: Upper >: Lower Lower and upper bounds used together The type Ahas both an upper and lower bound.

A =:= B  // A must be equal to B
A <:< B  // A must be a subtype of B
A <%< B  // A must be viewable as B

h2. 隐式转换

什么时候被执行？

h2. private[spark]

private[spark] class RDDCheckpointData[T: ClassTag](@transient rdd: RDD[T])
  extends Logging with Serializable {
  ...
}

这里的 private[spark] 可能是指类 RDDCheckpointData 的可见域。

h2. 匿名内部类

这里的 NextIterator 是一个 Abstract Class，不能直接实例化，必须先实现此类。

val iter = new NextIterator[(K, V)] {
  ...
  override def getNext() = {
  ...
}
}

h2. @ 的含义

表示继承

h2. 下划线的几种含义

参考资料：

"stackoverflow - What are all the uses of an underscore in Scala?":http://stackoverflow.com/questions/8000903/what-are-all-the-uses-of-an-underscore-in-scala

其他不理解的代码类型：

class InterruptibleIterator[+T](val context: TaskContext, val delegate: Iterator[T])

h2. "Scala 中 class 与 object 有什么区别？":http://stackoverflow.com/questions/1755345/scala-difference-between-object-and-class

You can think of the "object" keyword creating a Singleton object of a class, that is defined implicitely.

object A extends B with C

This will declare an anonymous class which extends B with the trait C and create a single instance of this class named A.

h2. "implicit 关键字的含义":http://stackoverflow.com/questions/10375633/understanding-implicit-in-scala

There are plenty of pages on the internet that will help you learn about implicits, for example: here.

The difference between your methods is that the one marked implicit will be inserted for you by the compiler when a Double is found but an Int is required. So

<pre>
implicit def doubleToInt(d: Double) = d.toInt
val x: Int = 42.0
</pre>

will work the same as

<pre>
def doubleToInt(d: Double) = d.toInt
val x: Int = doubleToInt(42.0)
</pre>

The conversion here is required because of the type annotation on the left hand side.

In your first snippet from Play, the implicit request refers to an implicit value (here of type Request), which is slightly different from an implicit def. It is taken from the current context.